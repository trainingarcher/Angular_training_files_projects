
	// Angular

	What is Angular..??
	-------------------

		Angular is a platform and leading front-end development framework for building single-page client applications using HTML and TypeScript. Angular is written in TypeScript. It implements core and optional functionality as a set of TypeScript libraries that you import into your applications.

		Angular is a development platform, built on TypeScript.  It is maintained mainly by Google and a community (Initial release	October 20, 2010).

		
		As a platform, Angular includes:

			- A component-based framework for building scalable web applications

			- A collection of well-integrated libraries that cover a wide variety of features, including routing, forms management, client-server communication, and more

			- A suite of developer tools to help you develop, build, test, and update your code

			- It was built with the Model-View-Controller concept in mind, though authors of the framework often called it “Model-View-*” or even “Model-View-Whatever”.

		//----------------------------------------------------------------------------

			Advantages of Angular:
			---------------------

		- Angular presents you not only the tools but also design patterns to build your project in a maintainable way.

		- It’s JavaScript, but better: Angular is built with TypeScript, which in turn relies on JS ES6.

		- No need to reinvent the bicycle:  With Angular, you already have lots of tools to start crafting the application right away. 

		- Testing is at the heart. Angular is meant to be thoroughly tested and it supports both unit and end-to-end testing with tools like Jasmine and Protractor.

		- Angular is mobile and desktop-ready, meaning you have one framework for multiple platforms.

		- Angular is actively maintained and has a large community and ecosystem. You can find lots of materials on this framework as well as many useful third-party tools.

		//----------------------------------------------------------------------------------

	Angular Features
	================

		- Angular supports multiple platforms: Desktop applications, Native applications, Progressive web applications

		- High Speed, Ultimate Performance: Universal support, Code splitting, Code generation

		- Productivity: Powerful templates, IDEs, Angular CLI

		- Full Stack Development:  Testing, Animation Support, Accessibility

		 It provides full stack development along with Node.js, Express.js, and MongoDB.

	//-------------------------------------------------------------------------------------- 

	- History and different versions of Angular
	============================================

		-  first version of Angular was Angular1.0 (also known as AngularJS) which was released in 2010.

		- Angular 2.0 was first introduced in October 2014. It was a complete rewrite of AngularJS

		- Angular 4 version was announced on 13 December 2016

		- Angular5 version was released on 1 Nov, 2017

		- Angular 7 released on October 18, 2018

		For more. https://github.com/angular/angular/blob/master/CHANGELOG.md

	//--------------------------------------------------------------------------------------

	Environment Setup
	==================

		- Install VS Code or JetBrains WebStorm

		- Install NodeJs ( https://nodejs.org/en/ )

			open command prompt and run following command to check the installation is successful or not

			C:\Users\archer>node -v
				v14.18.1

		- Visit the https://angular.io/resources

		- Install the Angular CLI

				Angular CLI to create projects, generate application and library code, and perform a variety of ongoing development tasks such as testing, bundling, and deployment.

				C:\Users\archer>npm install -g @angular/cli

		- Create a workspace and First Application (Created F:\angular)

				F:\angular>ng new first-ng-app

				 - hit N to Routing
				 - CSS hit enter key

		- After compliation run dir commad to see the files


			F:\angular>dir
			 Volume in drive F has no label.
			 Volume Serial Number is E0E2-42AB

			 Directory of F:\angular

			27-10-2021  01:33    <DIR>          .
			27-10-2021  01:33    <DIR>          ..
			27-10-2021  01:38    <DIR>          first-ng-app

		- open project dir and run code . to open the project in the VS Code

			F:\angular\first-ng-app>code .


		- Run the project using the command

				F:\angular\first-ng-app>ng serve --open 


		- To See information about the Workspace and project file structure just visit 

			https://angular.io/guide/file-structure

	//-------------------------------------------------------------------------------------

		 Why does Angular need Node.js?
		---------------------------------

		Angular does not need node.js directly. Node js is used for all the build and development tools.

		It is not mandatory to use node.js for developing angular application. You can very well go ahead without node.js for developing angular application but it would not be wise to do so. Let me explain you some of the reasons how node.js makes angular app development process easier for us:

		Node allows you to spin up a lightweight web server to host your application locally in your system.
		NPM (Node Package Manager) comes with node.js by default. NPM allows you to manage your dependencies. So, you don’t have to worry for operations like adding a dependency, removing some, updating your package.json.

		Third and the most important, npm gives you angular cli or ng cli(angular command line interface) . Angular CLI is a great tool for scaffolding your application. So, you don’t need to write boilerplates manually.

		Angular recommends the use of TypeScript. Now, your browser does not understand TypeScript. It needs to be transpiled*** to JavaScript. Also, you need to bundle your js files and stylesheets together with the html doc so as to get the web app CLI which is ready to be hosted. Angular CLI helps you to do all these behind the scene. By default, ng cli uses webpack for bundling your application and is very helpful for beginners who have just jumped into web development with angular as it abstracts such complexities.

	*** Transpiling is a specific term for taking source code written in one language and transforming into another language

	//----------------------------------------------------------------------------------


		// NPM - Node Package Manager
		-------------------------------

		Node Package Manager (NPM) is a command line tool that installs, updates or uninstalls Node.js packages in your application. It is also an online repository for open-source Node.js packages. The node community around the world creates useful modules and publishes them as packages in this repository.

			NPM is included with Node.js installation. After you install Node.js, verify NPM installation by writing the following command in terminal or command prompt.

				c:\> npm -v

			There are many things that npm does.

				- npm manages downloads of dependencies of your project.

				- Installs a single package

				- Updating is also made easy, by running npm update

				- In addition to plain downloads, npm also manages versioning.

				- Running Tasks: The package.json file supports a format for specifying command line tasks that can be run by using npm run <task-name>

	//-------------------------------------------------------------

	// What is the use of polyfills.ts file in Angular?

		Angular is built on the latest standards of the web platform. Targeting such a wide range of browsers is challenging because they do not support all features of modern browsers.

		You can compensate them by loading polyfill scripts on the host web page that implement missing features in JavaScript.

		Some features of angular may require additional polyfills

		For ex. Animation library relies on the standard web animation API, which is only available in chrome and Firefox today. You will need a polyfill to use animations in other browsers.

	//-------------------------------------------------------------------------------

		// What is module bundler?


		Module bundlers are tools for frontend developers used to bundle JavaScript modules into a single JavaScript files that can be executed in the browser.

		Examples of modern module bundlers are: webpack, rollup, fusebox, parcel, etc.

		Module bundler is required because:

		Browser does not support module system, although this is not entirely true nowadays
		
		It helps you manage the dependency relationship of your code, it will load modules in dependency order for you.

		It helps you to load your assets in dependency order, image asset, css asset, etc.

//------------------------------------------------------------------------------------------

		// What Is Lint Code? And Why Is Linting Important?

		Everyone knows that programming errors are bad. Some errors cause glitches that frustrate users. Others compromise the safety and security of a critical system. No matter what type of program you’re developing, avoiding these errors is important. That’s why many development teams rely on linting.

		Linting is the automated checking of your source code for programmatic and stylistic errors. This is done by using a lint tool (otherwise known as linter). A lint tool is a basic static code analyzer.

		Linting is important to reduce errors and improve the overall quality of your code. Using lint tools can help you accelerate development and reduce costs by finding errors earlier.


	// ==================================================================================

		TypeScript: just ref the Git repo.

	// ==================================================================================

		// Default Folder Structure 

 
		1. node_module: 
			- Provides npm packages to the entire workspace. Workspace-wide node_modules dependencies are visible to all projects.
			- This is the folder where all modules and libraries resides
			- Add/Remove the module packages
			- We will not touch this folder for development purpose.

		2. src:
			- This is the main work area/ app code resides inside this folder
			- Source files for the root-level application project.
				- app : Contains the component files in which your application logic and data are defined.
					- app.component : file curresponds to component
					- app.module.ts : It means this is module (collection of component, services, pipe etc)
					- app.component.spec.ts : These are unit test scripts
					- app.component.css : css file for perticular component.
					- app.component.html : html file for perticular component

				- assets : Contains image and other asset files to be copied as-is when you build your application.
				- environments: 
						Contains build configuration options for particular target environments. By default there is an unnamed standard development environment and a production ("prod") environment. You can define additional target environment configurations.
				- favicon.ico : An icon to use for this application in the bookmark bar.

				- index.html	
						The main HTML page that is served when someone visits your site. The CLI automatically adds all JavaScript and CSS files when building your app, so you typically don't need to add any <script> or <link> tags here manually.

				- main.ts	
						The main entry point for your application. Compiles the application with the JIT compiler and bootstraps the application's root module (AppModule) to run in the browser. 

				- polyfills.ts : Provides polyfill scripts for browser support. (make backward compatable)

				- styles.sass	
						Lists CSS files that supply styles for a project. The extension reflects the style preprocessor you have configured for the project.

				- test.ts	
						The main entry point for your unit tests, with some Angular-specific configuration. You don't typically need to edit this file.
		
		3. .browserslistrc
				 Share target browsers between different front-end tools, like Autoprefixer, Stylelint and babel-preset-env

		4. .editorconfig: 
				EditorConfig helps maintain consistent coding styles for multiple developers working on the same project across various editors and IDEs. The EditorConfig project consists of a file format for defining coding styles and a collection of text editor plugins that enable editors to read the file format and adhere to defined styles. EditorConfig files are easily readable and they work nicely with version control systems.

		5. .gitignore
				Specifies intentionally untracked files that Git should ignore.

		6. angular.json
				CLI configuration defaults for all projects in the workspace, including configuration options for build, serve, and test tools that the CLI uses, such as TSLint, Karma, and Protractor

		7. karma.conf.js: Karma Runner for out unit test scripts.

		8. package-lock.json
				Provides version information for all packages installed into node_modules by the npm client. 

		9. package.json
				Configures npm package dependencies that are available to all projects in the workspace. 

		10. README.md
				Introductory documentation for the root application.

		11. tsconfig.app.json
				Application-specific TypeScript configuration, including TypeScript and Angular template compiler options.

		12. tsconfig.json
				The base TypeScript configuration for projects in the workspace. All other configuration files inherit from this base file.

		13. tsconfig.spec.json
				TypeScript configuration for the application tests

		14. tslint.json	
				Application-specific TSLint configuration.


//----------------------------------------------------------------------------------------------------
	
		// Exact working of your angulat project: 

				Diagram

//=========================================================================================================

	//  Todo app  -- Application


		- create the new application using command (f:\angular)

			F:\angular>ng new todo-app

				-> say no to routing
				-> select CSS as style

				(The Angular CLI Will Create the project with std file structure)


		- open the project folder and again open it with vs code

			F:\angular>cd todo-app

			F:\angular\cd todo-app>code .

			F:\angular\cd todo-app>ng serve



	- Two json files
		- package.json:
		- angular.json:

	- src:
		- index.html
		- main.ts
		- styles.css

		- app: you can add more component here.

			for each component: 
				- app.component.css 	- style
				- app.component.html 	- structure
				- app.component.ts 		- logic
				- app.component.spec.   - Testing

			- module.ts

		- The app.component is the brain, variable defined over here can be accessed in the app.component.html using the javascript expression {{title}}

			- Note the variables from AppComponent are directly accessible in the app.component.html with the help of javascript expression


		- Add css to app.component.css


.logo {
  display: block;
  margin-left: auto;
  margin-right: auto;
}

.input-text {
  display: inline;
  margin: 0;
  border: none;
  border-radius: 0.4rem;
  padding: 10px;
}

.list ul li button {
  position: absolute;
  right: 0%;
  background: #f34541;
  color: #fff !important;
  text-transform: uppercase;
  text-decoration: none;
  margin-left: 10px;
  margin-right: 10px;
  padding: 10px;
  border-radius: 0.4rem;
  display: inline-block;
  border: none;
}

.add-btn {
  color: #fff !important;
  text-transform: uppercase;
  text-decoration: none;
  background: #7313cb;
  margin: 20px;
  padding: 10px;
  border-radius: 0.4rem;
  display: inline-block;
  border: none;
}

.app-title {
  text-align: center;
  color: #c1c1c1;
  font-size: 70px;
}
ul {
  /* remove default padding and margin from ul*/
  margin: 0px;
  padding: 0px;
}
.list ul li {
  display: block;
  width: 100%;
  text-decoration: none;
  color: #000000;
  background-color: #ffffff;
  line-height: 30px;
  border-bottom-style: solid;
  border-bottom-width: 1px;
  border-bottom-color: #cccccc;
  padding: 10px;
  position: relative;
}

.container {
  color: #fff;
  max-width: 500px;
  margin: auto;
}



	- copy the logo (logo.png) in the assets folder

	- open the app.component.html, delete all the contents

	- Now We have to write our own code


<div style="text-align: center">
  <img
    src="../assets/logo.png"
    alt="Logo"
    width="100"
    height="100"
    class="logo"
  /> 
  <h1 class="app-title"> Todo List </h1>
</div>

<div class="container">
  Add todo ....
  <br />
  <input type="text" class="input-text"  placeholder="Type a Todo" 
  [(ngModel)]="todovalue"
  (keyup.enter)="addItem()"
  />
  <button class="add-btn" (click)="addItem()">Add Todo</button>

  <div class="list">
    <ul>
       <li *ngFor="let item of list">
       <input type="checkbox" name="isDone" [(ngModel)]="item.isDone"/> 
        {{item.value}}
        <button class="btn" (click)="deleteItem(item.id)"> Delete </button>
      </li> 
    </ul>
  </div>
</div>


	- create the todo.ts in app folder, write the interface over there

		export interface Todo {
		    id: number;
		    value: string;
		    isDone: boolean;
		}


	- Import above tot in app.component, and Write a methids to insert and delete the items

import { Component } from '@angular/core';
import { Todo } from "./todo";
@Component({
  selector: 'app-root',
  templateUrl: './app.component.html',
  styleUrls: ['./app.component.css']
})
export class AppComponent {
  title = 'first-ng-app';
  todovalue : string = "";
  list : Todo[] = [];

  ngOnInit(){
    this.list = [];
    this.todovalue = "";
  }

  addItem(){
    if(this.todovalue==""){
      const newItem : Todo ={
        id : Date.now(),
        value : this.todovalue,
        isDone : false
      };
      this.list.push(newItem);
      console.log(this.list);
    }
    this.todovalue="";
  }

  deleteItem(id : number){
    this.list = this.list.filter( item => item.id !==id);
  }
}

	

	- add the formmodule in imports of file app.module.ts

import { NgModule } from '@angular/core';
import { BrowserModule } from '@angular/platform-browser';

import { AppComponent } from './app.component';
import { FormsModule } from '@angular/forms';

@NgModule({
  declarations: [
    AppComponent
  ],
  imports: [
    BrowserModule,
    FormsModule,
  ],
  providers: [],
  bootstrap: [AppComponent]
})
export class AppModule { }


	- Save all files and use ng serve to run the code

	//===================================================================================================================


		- Module: 

			A module is a software component or part of a program that contains one or more routines. One or more independently developed modules make up a program. An enterprise-level software application may contain several different modules, and each module serves unique and separate business operations.

				Means Simply Collection of Things

			An Angular app is made up of three types of artifacts: components (which includes directives and pipes), child modules, and services. An Angular module encapsulates these artifacts as one compilation unit.
	

			Modules are a way to organize an app and extend its capabilities with external libraries. Angular libraries are also built using Angular modules. Examples include FormsModule, HttpClientModule, and RouterModule. Many external libraries are also available as Angular modules, for example, Material Design, Ionic, and AngularFire2.

			Angular components, directives, and pipes focus on particular feature areas, business domains, workflows, or common utilities. Angular services might be internally developed, like something you'd develop for yourself, or can be imported from external sources, such as the Angular router and HTTP client.

				( * Pipes are for formatting data, and directives are to alter the behavior/appearance of 
				    an element
				  * Routing basically means navigating between pages
				)


			Modules can be eagerly loaded when the app starts or lazily loaded asynchronously by the router.


			- An Angular Module's Metadata:
			------------------------------

			An Angular module's metadata, which is specified using the @NgModule decorator, does the following:

				- Declares which components, directives, and pipes belong to the module

				- Makes some of those components, directives, and pipes public so that other module's component templates can use them.

				- Imports other modules with the components, directives, and pipes that components in the current module need

				- Provides services that other app components 


			Every Angular app has at least one module, which is called the root module or app-level module. You bootstrap this app-level module or root module to launch the application.

			Root Module: 
	
			import { BrowserModule } from '@angular/platform-browser';
			import { NgModule } from '@angular/core';

			import { AppComponent } from './app.component';

			// @NgModule decorator with its metadata
			@NgModule({
			  declarations: [AppComponent],
			  imports: [BrowserModule],
			  providers: [],
			  bootstrap: [AppComponent]
			})
			export class AppModule {}


			Notice that in the NgModule directive, you are passing an object that has the following four array type properties:

			- declarations: In this array, you specify which components, directives, and pipes belong to this module.

			- imports: In this array, you import eagerly loaded modules.
			
			- providers: In this array, you specify all the services that can be used across the app in any component, directive, or pipe.

			- bootstrap: In this array, you specify the component that should be loaded at the start of the app.



			Any feature module will have the first three arrays (declarations, imports, providers) but not the fourth array (bootstrap).

		In a small app, the root module or app-level module is enough to organize different components, directives, pipes, and services. But as the app grows, you should refactor the root module into feature modules, which represents related functionality. You may then import these modules in the app-level module if you want these modules to be eagerly loaded or in the routing module through routes if you want them to be lazily loaded.



		- What is {Eager Loading, Lazy Loading, Pre-Loading} in Angular?

			1. What is Eager Loading?
			Feature modules under Eager Loading would be loaded before the application starts. This is the default module-loading strategy.
			
			2. What is Lazy Loading?
			Feature modules under Lazy Loading would be loaded on demand after the application starts. It helps to start application faster.
			
			3. What is Pre-Loading?
			Feature Modules under Pre-Loading would be loaded automatically after the application starts


		- Types of Feature Modules
		---------------------------

		There are following types of feature modules:

			- Domain Feature Modules
			- Routed Feature Modules
			- Routing Modules
			- Service Feature Modules
			- Widget Feature Modules
			- Shared Feature Modules


			- Domain Feature Modules

			The user experience, such as editing an event or placing an order, for a particular app is delivered by a domain feature module.

			Domain feature modules rarely have providers. If they have providers, the lifetime of the provided services should be the same as the lifetime of the module. Domain feature modules are imported exactly once by a larger feature module.

			They might be imported by the root AppModule of a small application that lacks routing.

				- Routed Feature Modules

			In routed feature modules, the top components are the targets of router navigation routes. Their components never appear in the template of an external component. Routed feature modules rarely have providers. If they have providers, the lifetime of the provided services should be the same as the lifetime of the module.

				- Routing Modules

			The routing module define routes and provides the routing configuration. It adds router configuration to the module's import and separates routing concerns from its companion module. A routing module should only be imported by its companion module, and it does not have its own declarations.

				- Service Feature Modules

			Utility services such as messaging and accessing data are provided by service feature modules. These modules consist of providers only and have no declarations. The root AppModule is the only module that should import service modules.

				- Widget Feature Modules

			Components, directives, and pipes are made available to external modules using widget feature modules. A widget feature module consists entirely of declarations and rarely has any providers.

				- Shared Feature Modules: 

			A shared NgModule makes a set of components, directives, and pipes available to other NgModules.



		//-------------------------------------------------------------


		- Creating your Own Module:

		- Run the command

				> ng generate module student  (or ng g m student)

					It will create the module student under the src/app/student having file student.ts

					import { NgModule } from '@angular/core';
					import { CommonModule } from '@angular/common';

					@NgModule({
					  declarations: [],
					  imports: [
					    CommonModule
					  ]
					})
					export class StudentModule { }


			- Now Just import the module into the app module(root module), There are two ways, lets see first manually

			- open the app.module.ts and import the StudentModule and add StudentModule in to imports array

				import { NgModule } from '@angular/core';
				import { BrowserModule } from '@angular/platform-browser';
				import { StudentModule } from './student/student.module';
				import { AppComponent } from './app.component';

				@NgModule({
				  declarations: [
				    AppComponent
				  ],
				  imports: [
				    BrowserModule,
				    StudentModule
				  ],
				  providers: [],
				  bootstrap: [AppComponent]
				})
				export class AppModule { }


	//-----------------------------------------------------------------------------------------------

		// Using Components in Angular

				An Angular app is made up of three types of artifacts: components (which includes directives and pipes), child modules, and services. An Angular module encapsulates these artifacts as one compilation unit.

				Note that the collection of component is webpage. there are two different
				approches of page design:

					- Traditional Approch (DOM Based):

						- First you have to write the html which is the static portion of your application.

						- Then you have to write the JavaScript which is the dynamic portion of your application.

							JavaScript is embeeded into the html and when the html loads, javascript also gets loaded. Javascript manipulates the DOM and you will get the dynamic functionality.

							Means, There is implicit divide.

						suppose, you want to display the date and time

				html 									JavaScript

	- Create the <div> and <p>					- code to get the date and time
	- Add button 								- update the <p> DOM Element
												- Need the function to handle the button click


			<html>
				<head>
					<script>
						function printDate(){
							const d=new date();
							document.getElementById("demo").innerHTHL=d;
						}
					</script>
				</head>

				<body>
					<h2> Date and Time Display </h2>
					<p id="demo"> display here </p>
					<button onclick="printdate()"> Cilck Me </buttion>
				</body>
			</html>


	//--------------------------------------------------------------------------------

		- Component based Approch:
		The concept of component-based design envisions building websites out of ready-made elements (components), which are designed and programmed segments to be used as building blocks for your website. What is more, thanks to their modular nature, they can be easily reused on all subpages. 

			fig. cmpmodel


			which you can assemble in various ways to build your subpages by composing and arranging them in various ways in order to achieve the desired goal. A component is like a ready-made element, which you can fill with any content or add graphic elements to it. What is more, components are not tied to specific subpages, which means that you can use them throughout your website. Examples of such components include text blocks, a photo banner, a contact form, or a call-to-action block.


			- Advantages of using component-based websites include:
			-------------------------------------------------------

				- One of the most important ones is definitely versatility in reusing these building blocks since they enable you to freely shape and rearrange your website

				- By building a component-based website, in reality, you’re building a website management system.
			
				- reusing components on various subpages, all changes in design or code modifications of a given element are easier

				- minimising the cost of managing the website, as well as introducing changes in the content and structure of its subpages,
				
				- simplicity and intuitiveness of the components and their use

				- ease of adding new blocks to a website based on ready-made components, enabling easy expansion according to the needs and demands

				- easy website administration and management in companies, where component-based websites can be managed by a group of people. 


			- Creating our Own Component: 

				A component controls a patch of screen called a view.

				or 
				
				The component is a self-sufficient piece of a web application that can be plugged into anywhere, that knows what to do.


					fig. component_arc



				>ng generate component clock (will create the component in the app)


				project : module-component-demo



	 - Different ways of creating the component: 

	 	> ng generate component header
	 	> ng g c dummy  --skipTests=true        -- without spec.ts
	 	> ng g c sidebar --inlineTemplet=true   -- without template
	 	> ng g c footer --inlineStyle=true   	-- without css
	 	> ng g c chat -s=true -t=true 			-- without style and templet

//---------------------------------------------------------------------------------

	// Data Binding in Angular: 

		we are going to look at the How Data Binding works in Angular with examples. Angular Components are useless if they do not show any dynamic data. They also need to respond to user interactions and react to events. The data binding kees both component & view in sync with each other. We use techniques like Interpolation, Property Binding, Event Binding & Two Way Binding to bind data. Also we have to learn how to use the ngModel directive to achieve the two-way binding in Angular Forms.

		 What is Angular Data Binding?
		 ------------------------------

		 	Data binding is a technique, where the data stays in sync between the component and the view. Whenever the user updates the data in the view, Angular updates the component. When the component gets new data, the Angular updates the view.

		 	There are many uses of data binding. You can show models to the user, dynamically Change element style, respond to user events, etc


		 	Data Binding in Angular
				-----------------------

			The data binding in Angular can be broadly classified into two groups. 

			- One way binding 
			- two-way binding

	One way binding
	================

		In one way binding data flows from one direction. Either from view to component or from component to view.

		From Component to View
		------------------------
			To bind data from component to view, we make use of Interpolation & Property Binding.

			- Interpolation:
			-----------------

				Interpolation allows us to include expressions as part of any string literal, which we use in our HTML. The angular evaluates the expressions into a string and replaces it in the original string and updates the view. You can use interpolation wherever you use a string literal in the view

				The Angular uses the {{ }} (double curly braces) in the template to denote the interpolation. The syntax is as shown below

				{{ templateExpression }}

				The content inside the double braces is called Template Expression

				The Angular first evaluates the Template Expression and converts it into a string. Then it replaces Template expression with the result in the original string in the HTML. Whenever the template expression changes, the Angular updates the original string again

				Example:

				In *.html
					 Welcome,  {{firstName}} {{lastName}}

				In *.ts

				import { Component } from '@angular/core';
				@Component({
				  selector: 'app-root',
				  templateUrl: './app.component.html',
				  styleUrls: ['./app.component.css']
				})
				export class AppComponent {
				  firstName= 'Rushi';
				  lastName=” Gandhi”
				}

				Run the app and you will see Welcome, The Angular replaces both {{firstName}} & {{lastName}} with the values of firstName & lastName variable from the component.

				Also, whenever the values of firstName & lastName change, Angular updates the view.



			- Property binding:
			-------------------

				The Property binding allows us to bind HTML element property to a property in the component. Whenever the value of the component changes, the Angular updates the element property in the View. You can set the properties such as class, href, src, textContent, etc using property binding. You can also use it to set the properties of custom components or directives (properties decorated with @Input).

				The Property Binding uses the following Syntax

					[binding-target]=”binding-source”

				The binding-target (or target property) is enclosed in a square bracket []. It should match the name of the property of the enclosing element.

				Binding-source is enclosed in quotes and we assign it to the binding-target. The Binding source must be a template expression. It can be property in the component, method in component, a template reference variable or an expression containing all of them.
				Whenever the value of Binding-source changes, the view is updated by the Angular.

				Example

				app.component.html

					<h1 [innerText]="title"></h1>
					<h2>Example 1</h2>
					<button [disabled]="isDisabled">I am disabled</button>
				 
				 
				app.component.ts
 
					import { Component } from '@angular/core';
					 
					@Component({
					  selector: 'app-root',
					  templateUrl: './app.component.html',
					  styleUrls: ['./app.component.css']
					})
					export class AppComponent {
					  title="Angular Property Binding Example"
					  isDisabled= true;
					 
					}

					- Class Binding

					You can set the class in the following ways.

						- ClassName Property binding
						- Set the Class attribute with class binding
						- ngClass directive


					- Style Binding

					You can set the class in the following ways. 

						- Style Binding
						- ngStyle directive

					- Attribute binding

					Sometimes there is no HTML element property to bind to. The examples are aria (accessibility) Attributes & SVG. In such cases, you can make use of attribute binding

					The attribute syntax starts with attr followed by a dot and then the name of the attribute as shown below

						<button [attr.aria-label]="closeLabel" (onclick)="closeMe()">X</button>



		From View to Component:
		=======================

		Event Binding
			Event binding allows us to bind events such as keystrokes, clicks, hover, touch, etc to a method in component. It is one way from view to component. By tracking the user events in the view and responding to it, we can keep our component in sync with the view. For Example, when the user changes input in a text box, we can update the model in the component, run some validations, etc. When the user submits the button, we can then save the model to the backend server.

			Angular uses the following syntax for event binding

			(target-event)="TemplateStatement"

			Angular event binding syntax consists of a target event name within parentheses on the left of an equal sign, and a quoted template statement on the right.

			For Example,
			 
			 <button (click)="onSave()">Save</button>
 
				The above example binds the click event of a button to a onSave() method in the component class. Whenever the user clicks on the button, the Angular invokes the onSave() method.


	Two Way binding
	===============

		Two-way binding means that changes made to our model in the component are propagated to the view and that any changes made in the view are immediately updated in the underlying component

		Two-way binding is useful in data entry forms. Whenever a user makes changes to a form field, we would like to update our model. Similarly, when we update the model with new data, we would like to update the view as well

		The two-way binding uses the special syntax known as a banana in a box [()]

			<someElement [(someProperty)]="value"></someElement>.

		The above syntax sets up both property binding & event binding. But to make use of it, the property must have the change event with the name <propertyName>Change

		But, angular has a special directive ngModel, which sets up the two-way binding

		ngModel

		The Angular uses the ngModel directive to achieve the two-way binding on HTML Form elements. It binds to a form element like input, select, selectarea. etc.

		The ngModel directive is not part of the Angular Core library. It is part of the @angular/forms. You need to import the FormsModule package into your Angular module.
		 
		import { FormsModule } from '@angular/forms';
		 
		Then you can use it using the two-way binding syntax as shown below

		<input type="text" name="value" [(ngModel)]="value">
		 
		When you bind to a ngModel directive, behind the scene it sets up property binding & event binding. It binds to the value property of the element using property binding. It then uses the ngModelChange event to sets up the event binding to listen to the changes to the value.

	
	  // Using @input() decorator:  Passing data from parent to child component.

	  // Using @output() decorator: passing data from child to parent.

	  // Combined Use of @Input() and @Output() Decorators   

	 // Two Way data binding using the  @Input() and @Output() Decorators 

	 	 // ref shared project iodecoratordemo

	 		components:

	 			- child 
	 			- colordish
	 			- friendlist
	 			- taskmaster
	 			- productprice


//======================================================================

	// Component Life Cycle Hook:

	The life cycle hooks are the methods that angular invokes on directives and components as it creates, changes, and destroys them. Using life-cycle hooks we can fine-tune the behavior of our components during creation, update, and destruction.

		Angular lets us know when these events happen using lifecycle hooks

			The Angular life cycle hooks are nothing but callback function, which angular invokes when a certain event occurs during the component’s life cycle.

	
		For example,

				- ngOnInit when Angular initializes the component for the first time.
				- When a component’s input property change, Angular invokes ngOnChanges
				- If the component is destroyed, Angular invokes ngOnDestroy


			Angular lifecycle hooks
			=======================

			Here is the complete list of life cycle hooks, which angular invokes during the component life cycle. Angular invokes them when a certain event occurs.

			ngOnChanges
			ngOnInit
			ngDoCheck
			ngAfterContentInit
			ngAfterContentChecked
			ngAfterViewInit
			ngAfterViewChecked
			ngOnDestroy


			Change detection Cycle:
			------------------------

				Before diving into the lifecycle hooks, we need to understand the change detection cycle.

				Change detection is the mechanism by which angular keeps the template in sync with the component

				Angular raises the life cycle hooks during the important stages of the change detection  mechanism.

				Constructor
				-----------

					Life Cycle of a component begins, when Angular creates the component class. First method that gets invoked is class Constructor.

					Constructor is neither a life cycle hook nor it is specific to Angular.  It is a Javascript feature. It is a method which is invoked, when a class is created. 

					Angular makes use of a constructor to inject dependencies.


				ngOnChanges
				----------
					The Angular invokes ngOnChanges life cycle hook whenever any data-bound input property of the component or directive changes.  


				ngOnInit
				---------
					The Angular raises the ngOnInit hook, after it creates the component and updates its input properties. It raises it after the ngOnChanges hook.

					This hook is fired only once and immediately after its creation (during the first change detection).


				ngDoCheck
				---------
					The Angular invokes the ngDoCheck hook event during every change detection cycle. This hook is invoked even if there is no change in any of the properties.

					Angular invokes it after the ngOnChanges & ngOnInit hooks.


				ngAfterContentInit
				------------------
					ngAfterContentInit Life cycle hook is called after the Component’s projected content has been fully initialized.

			  	ngAfterContentChecked
				----------------------
					ngAfterContentChecked Life cycle hook is called during every change detection cycle after Angular finishes checking of component’s projected content. Angular also updates the properties decorated with the ContentChild and ContentChildren before raising this hook. Angular calls this hook even if there is no projected content in the component

				ngAfterViewInit
				-----------------
					ngAfterViewInit hook is called after the Component’s View & all its child views are fully initialized. Angular also updates the properties decorated with the ViewChild & ViewChildren properties before raising this hook. 


				ngAfterViewChecked
				-------------------
					The Angular fires this hook after it checks & updates the component’s views and child views. This event is fired after the ngAfterViewInit and after that during every change detection cycle


				ngOnDestroy
				------------
					This hook is called just before the Component/Directive instance is destroyed by Angular



			How to Use Lifecycle Hooks:

				- Import Hook interfaces
				- Declare that Component/directive Implements lifecycle hook interface
				- Create the hook method

				The Order of Execution of Life Cycle Hooks
				The Angular executes the hooks in the following order

				On Component Creation

				OnChanges
				OnInit
				DoCheck
				AfterContentInit
				AfterContentChecked
				AfterViewInit
				AfterViewChecked

				When the Component with Child Component is created

				OnChanges
				OnInit
				DoCheck
				AfterContentInit
				AfterContentChecked
					Child Component -> OnChanges
					Child Component -> OnInit
					Child Component -> DoCheck
					Child Component -> AfterContentInit
					Child Component -> AfterContentChecked
					Child Component -> AfterViewInit
					Child Component -> AfterViewChecked
				AfterViewInit
				AfterViewChecked
				
				After The Component is Created

				OnChanges
				DoCheck
				AfterContentChecked
				AfterViewChecked


//============================================================================
//============================================================================

	// Directives AND Pipes:
	//=======================

		Directives: 
		-----------

		The Angular directive helps us to manipulate the DOM. You can change the appearance, behavior, or layout of a DOM element using the directives. They help you to extend HTML. 

		The Angular directives are classified into three categories based on how they behave. 


		- Components / Component Directives: directives with a template. This type of directive is the most common directive type.
				- every angular directive have atleast one component directive
				- have its own templet
				- events attached
				- AppComponent is the example

		- Structural Directives: directives that change the DOM layout by adding and removing DOM elements.
				- updates structure of a view
				- ngFor, ngIf and ngSwitch

		- Attribute Directives: directives that change the appearance or behavior of an element, component, or another directive.
				- ngStyle, ngClass, ngModel

		- Custom Directives:

					// ----------------------------------------------------------------------------

			- Component Directives
			------------------------

				Components = Directive + Template

			Components are directives that include a template that is rendered in the place of the component. Components inherit all of the functionality and usability of directives plus a provided template. Angular uses a HTML-like template syntax that enables web developers to get started quickly with Angular. Templates can also be styled using vanilla CSS, Scss or LESS. Simply modify the extension of the file and Angular will compile the Scss or LESS.

			We'll specify the template and styles using the @Component() decorator's metadata. For example, we can specify the template and CSS inline in the metadata:

			@Component({
			  selector: 'app-hello-world',
			    template: `<h1>Hello, World!</h1>`,
			    styles: [`h1 { font-weight: bold; }`],
			})
			export class HelloWorldComponent { }


-----------------------------------------------------------------------------

				- Structural Directives: directives that change the DOM layout by adding and removing DOM elements.
					asterisk (*) used to represent the structural directive


				Commonly used structural directives

				- ngFor:
				---------

					The ngFor is an Angular structural directive, which repeats a portion of the HTML template once per each item from an iterable list (Collection). 

					Example of ngFor

					 
					<tr *ngFor="let customer of customers;">
					    <td>{{customer.customerNo}}</td>
					    <td>{{customer.name}}</td>
					    <td>{{customer.address}}</td>
					    <td>{{customer.city}}</td>
					    <td>{{customer.state}}</td>
					</tr>


				- ngIf:
				--------
					The ngIf Directives is used to add or remove HTML elements based on an expression. The expression must return a boolean value. If the expression is false then the element is removed, else the element is inserted

					Example of ngIf
					 
					<div *ngIf="condition"> 
					    This is shown if condition is true
					</div>

				- ngSwitch
				-------
					The ngSwitch directive lets you add/remove HTML elements depending on a match expression. ngSwitch directive used along with ngSwitchCase and ngSwitchDefault

					The example of ngSwitch  (getting my voice - > msg me)

					 
					<div [ngSwitch]="Switch_Expression"> 
					    <div *ngSwitchCase="MatchExpression1”> First Template</div>
					    <div *ngSwitchCase="MatchExpression2">Second template</div> 
					    <div *ngSwitchCase="MatchExpression3">Third Template</div> 
					    <div *ngSwitchCase="MatchExpression4">Third Template</div> 
					    <div *ngSwitchDefault?>Default Template</div>
					</div>

		//--------------------------------------------------------------------------

			- Attribute Directives: directives that change the appearance or behavior of an element, component, or another directive.

			- ngStyle
				ngStyle is used to change the multiple style properties of our HTML elements. We can also bind these properties to values that can be updated by the user or our components.

				Example of ngStyle

			<div [ngStyle]="{'color': 'blue', 'font-size': '24px', 'font-weight': 'bold'}">
				some text
			</div>


			- ngClass
					The ngClass is used to add or remove the CSS classes from an HTML element. Using the ngClass one can create dynamic styles in HTML pages

					Example of ngClass

					<div [ngClass]="'first second'">...</div>

			- ngModel
					The ngModel directive is used the achieve the two-way data binding. 

					What is ngModel
						The Angular uses the ngModel directive to achieve the two-way binding on HTML Form elements. It binds to a form element like input, select, selectarea. etc.

						Internally It uses the ngModel in property, binding to bind to the value property and ngModelChange which binds to the input event.

					How to use ngModel
						The ngModel directive is not part of the Angular Core library. It is part of the FormsModule library. You need to import the FormsModule package into your Angular module.

						In the template use the following syntax

						<input type="text" name="value" [(ngModel)]="value">
						 
						The ngModel directive placed inside the square & parentheses as shown above. This is assigned to the Template Expression. Template Expression is the property in the component class
						(REF- todo-app)



						examples: directivedemo project



//========================================================================================

		Pipes:
		======

		A simple definition of pipe- it is a decorative function in Angular used to manipulate DOM. It takes an untransformed value as input and returns a transformed value as output.

		or 

		Angular Pipes takes data as input and formats or transform the data to display in the template. We use them to change the appearance of the data before presenting it to the user. The most common use case of pipes is displaying the dates in the correct format as per the user’s locale.

		Various built-in pipes are provided by Angular

		 AsyncPipe 		CurrencyPipe 		 DatePipe 		 DecimalPipe 		 I18nPluralPipe 

		 I18nSelectPipe  		JsonPipe  		KeyValuePipe  		LowerCasePipe  		PercentPipe

		  SlicePipe  		TitleCasePipe  		UpperCasePipe


	Angular Pipes Syntax

		The syntax of the pipe is as follows

		Expression | pipeOperator[:pipeArguments]
		 
		Where

		Expression: is the expression, which you want to transform
		| : is the Pipe Character
		pipeOperator : name of the Pipe
		pipeArguments: arguments to the Pipe


	How to use pipe in code?

			The example code below demonstrates the use of date pipe. See how the output is manipulated on the DOM.

			app.component.ts
			----------------
			 
			cdate: Date;
			 
			constructor() {
			  this.cdate = new Date();
			}
			 
			app.component.html
			------------------
			 
			<b>Date Pipe Example: </b>
			<span>{{ cdate | date: 'shortDate'}}</span>
			 
			Result with Date Pipe

			Date Pipe Example: 11/07/21

//----------------------------------------------------------------------------

			Pure and Impure Pipe

				Pure pipe is a type of function which runs only when a change has been done in the input value. They are called as pure because they do not run every time a state is changed or a change detection happened. They are only called when a value is changed. This improves the performance (see below case study).
 
				import { Pipe, PipeTransform } from '@angular/core';
				 
				@Pipe({
				  name: 'customUpper'
				})
				export class CustomUpperPipe implements PipeTransform {
				 
				  transform(value: string): string {
				    console.log('Custom pipe is called');
				    return value.toUpperCase();
				  }
				}
				 
				Impure pipe is a type of function which runs for every Angular lifecycle events as well as whenever state or input value changes.

				@Pipe({
				  name: 'customUpper',
				  pure: false  // <--- this will convert a pure pipe to impure one
				})
				 
				It is not advisable to use a method to manipulate your DOM. Use pipes instead of methods if you have a big application and want to improve performance.


	Example: 

				<!-- Built-in Pipes -->
				
				UpperCasePipe & LowerCasePipe
				As the name suggests, these pipes transform the string to Uppercase or lowercase

				{{str|uppercase}} <br/>
				{{str|lowercase}}
				<hr>


				<!-- date -->
				<h3>Unformatted Current date: {{currdate}}</h3><br/>
				<h3>Formatted Current date: {{currdate|date}}</h3>
				<hr>


				<!-- Passing arguments to pipes -->
				We can also pass optional arguments to the pipe. The arguments are added to the pipe using a colon (:) sign followed by the value of the argument. If there are multiple arguments separate each of them with the colon (:). For example, we can pass the format as the argument to the date pipe, which is Optional. The medium is one of the valid value of the format argument, which displays the date in yMMMdjms format. The example code is as shown below.

					{{toDate | date:'medium'}}

				
				<h3>Formatted Current date: {{currdate|date:'medium'}}</h3>



				<!-- Chaining Pipes -->
				Pipes can be chained together to make use of multiple pipes in one expression. For example in the following code, the toDate is passed to the Date Pipe. The output of the Date pipe is then passed to the uppercase pipe.

				toDate | date | uppercase

				<h3>Formatted Current date: {{currdate|date:'medium'|uppercase}}</h3>


				<!-- Example of Datepipe -->

				The Date pipe formats the date according to locale rules. The syntax of the date pipe is as shown below

					date_expression | date[:format]
					 
					Where

					- date_expression is a date object or a number
					- date is the name of the pipe
					- format is the date and time format string which indicates the format in which date/time components are displayed.

				<p>medium : {{currdate | date:'medium'}} </p>
				<p>short : {{currdate | date:'short'}} </p>
				<p>fullDate : {{currdate | date:'fullDate'}} </p>
				<p>longDate : {{currdate | date:'longDate'}} </p>
				<p>mediumDate : {{currdate | date:'mediumDate'}} </p>
				<p>shortDate : {{currdate | date:'shortDate'}} </p>
				<p>mediumTime : {{currdate | date:'mediumTime'}} </p>
				<p>dd-MM-y : {{currdate | date:'dd-MM-y'}} </p>
				<p>dd-MM-yy HH:mm : {{currdate | date:'dd-MM-yy HH:mm'}} </p>



				<!-- SlicePipe
				Creates a new List or String containing a subset (slice) of the string or array.  -->

				Syntax

					array_or_string_expression | slice:start[:end]
					 
					Where

					- array_or_string_expression is the string to slice
					- slice is the name of the pipe
					- start is the start position/index from where the slicing will start
					- end is the ending index/position in the array/string

					The slice pipes take two arguments. The first argument start is the starting index of the string/array. The second argument end is the ending index of the string/array. If the start or end index is negative then the index is counted from end of the string/array

				<p>Complete String :{{str}} </p>
				<p>Example 1 :{{str | slice:11:20}} </p>
				<p>Example 2 :{{str | slice:-9}} </p>



				<!-- DecimalPipe / NumberPipe -->
					The Decimal Pipe is used to Format a number as Text. This pipe will format the number according to locale rules.

					Syntax
					 
					number_expression | number[:digitInfo]
					 
					Where

					number_expression is the number you want to format

					number is the name of the pipe

					digitInfo is a string which has the following format

					{minIntegerDigits}.{minFractionDigits}-{maxFractionDigits}

						Where

						minIntegerDigits is the minimum number of integer digits to use. Defaults to 1.

						minFractionDigits is the minimum number of digits after fraction. Defaults to 0.

						maxFractionDigits is the maximum number of digits after fraction. Defaults to 3.

				<p> Unformatted :{{num}}</p>
				<p> Formatted :{{num | number}}</p>
				<p> Formatted :{{num | number:'3.1-2'}}</p>
				<p> Formatted :{{num | number:'7.1-5'}} </p>


			<!-- PercentePipe
				Formats the given number as a percentage according to locale rules. -->


					number_expression | percent[:digitInfo]
 
 					Where

					number_expression is the number you want to format

					percent is the name of the pipe

					digitInfo is a string which has the following format. It is similar to used in decimal pipe

				<p>Unformatted :{{per}} </p>
				<p>Example 1 :{{per | percent }} </p>
				<p>Example 2 :{{per | percent:'1.2-2'}} </p>


				<!-- CurrencyPipe -->

				Formats a number as currency using locale rules.
 
					number_expression | currency[:currencyCode[:symbolDisplay[:digitInfo]]]
					 
					Where

					number_expression currency to format a number as currency.

					Currency is the name of the pipe

					currencyCode is the ISO 4217 currency code, such as USD for the US dollar and EUR for the euro.

					symbolDisplay is a boolean indicating whether to use the currency symbol or code. Use true to display symbol and false to use code

					digitInfo is similar to the one used in decimal pipe

				<p>Unformatted :{{cur}} </p>
				<p>Example 1 :{{cur | currency }} </p>
				<p>Example 2 :{{cur | currency:'INR':true:'4.2-2'}} </p>




//=====================================================================================

	// Services and Dependency Injection: 

		// What is an service and Angular Service

	Services allow us to create reusable code and use it every component that needs it. The Services can be injected into components and other services using the dependency injection system. The dependencies are declared in the Module using the Provider’s metadata. The Angular creates a tree of injector & Providers that resembles the Component Tree. This is called the hierarchical pattern.

	or 

	Service is a class that has the purpose of Providing a Service to a Component, Directive, or to another Service. The Service may be fetching data from the back end, running a business logic, etc

	or

	Service is a piece of reusable code with a focused purpose. A code that you will use in many components across your application

	suppose, Our components need to access the data. You can write data access code in each component, but that is very inefficient and breaks the rule of single responsibility. The Component must focus on presenting data to the user. The task of getting data from the back-end server must be delegated to some other class. We call such a class a Service class. Because it provides the service of providing data to every component that needs it.


		Angular Services are used for
				
				- Features that are independent of components such a logging services
				- Share logic or data across components
				- Encapsulate external interactions like data access


		Advantageous of Angular Service

				- Services are easier to test.
				- They are easier to Debug.
				- We can reuse the service at many places.

//------------------------------------------------------------------------------------------------

	Creating a Service in Angular: (Demo):

	- Create a new file under the folder src/app and call it product.ts

			export class Product { 
	 
			    constructor(productID:number,    name: string ,   price:number) {
			        this.productID=productID;
			        this.name=name;
			        this.price=price;
			    }
			 
			    productID:number;
			    name: string;
			    price:number;
			 
			}


	- build an Angular Service, which returns the list of products.  i.e. Create a new file  under the folder src/app and call it product.service.ts 


			import { Product } from './product'
			export class ProductService{
			 
			    public  getProducts() {
			 
			        let products:Product[];
			 
			        products=[
			            new Product(1,'Memory Card',500),
			            new Product(2,'Pen Drive',750),
			            new Product(3,'Power Bank',100)
			        ]
			 
			        return products;               
			    }
			}


			(we have hardcoded the products. In real life, you would send an HTTP GET request to your back end API to get the data)


	-  invoke the ProductService from the component. i.e the app.componet.ts
		

			import { Component } from '@angular/core';
			import { Product } from './product';
			import { ProductService } from './product.service';

			@Component({
			  selector: 'app-root',
			  templateUrl: './app.component.html',
			  styleUrls: ['./app.component.css']
			})
			export class AppComponent {
			  title = 'servicedemo';

			  products:Product[] = [];
			  productService;

			  constructor(){
			    this.productService=new ProductService();
			  }

			  getProducts() {
			    
			    this.products = this.productService.getProducts();
			  }
			}

		( In real-life Angular Apps, we use the Dependency Injection in Angular to inject the ProductSerivce in the constructor.)


		- display the Products to user, i.e. Using app.component.html file

		<div class="container">
			  <h1 class="heading"><strong>Services Demo </strong> </h1>

			  <button type="button" (click)="getProducts()">Get Products</button>
			  <hr>
			   <div class='table-responsive'>
			          <table class='table'>
			              <thead>
			                  <tr>
			                      <th>ID</th>
			                      <th>Name</th>
			                      <th>Price</th>
			                  </tr>
			              </thead>
			              <tbody>
			                  <tr *ngFor="let product of products;">
			                      <td>{{product.productID}}</td>
			                      <td>{{product.name}}</td>
			                      <td>{{product.price}}</td>
			                  </tr>
			              </tbody>
			          </table>
			      </div>
			</div>


								  data access
			database	<-------	service		<-------	Component (*.html, *.css, *.ts)
						------->				-------->				
																		|
																		V
																	data display using *.html



//---------------------------------------------------------------------------------

	Directly instantiating the service, as shown above, has many disadvantageous

	- The ProductService is tightly coupled to the Component. If we change the ProductService class definition, then we need to update every code where service is used

	- If we want to change ProductService with BetterProductService, then we need to search wherever the ProductService is used and manually change it

	- Makes Testing difficult. We may need to provide mockProductService for testing and use the ProductService for Production.

	- Our Component Class has now tied one particular implementation of ProductService. It will make it difficult to reuse our components.

	- We would also like to make our ProductService singleton so that we can use it across our application.

	We can solve this by using the Angular Dependency injection

	(Dependency Injection (DI) is a technique in which a class receives its dependencies from external sources rather than creating them itself.)


		So AppComponent constructure used for the Dependency Injection

		export class AppComponent {    
		   products:Product[];    
		 
		   constructor(private productService:ProductService) {    
		 		
		   }    
		 
		   getProducts() {        
		       this.products=this.productService.getProducts();    
		   }
		}

	Now It is loosely coupled, so it become easy to test, reuseable


	Angular Dependency Injection Framework:
	----------------------------------------

	Angular Dependency Injection framework implements the Dependency Injection in Angular. It creates & maintains the Dependencies and injects them into the Components, Directives, or Services.

	There are five main players in the Angular Dependency injection Framework.

	- Consumer
		The Consumer is the class (Component, Directive, or Service) that needs the Dependency. In the above example, the AppComponent is the Consumer.

	- Dependency
		The Service that we want to in our consumer. In the above example the ProductService is the Dependency

	- Injection Token (DI Token)
		The Injection Token (DI Token) uniquely identifies a Dependency. We use DI Token when we register dependency

	- Provider
		The Providers Maintain the list of Dependencies along with their Injection Token. It uses the Injection Token is to identify the Dependency.

	- Injector
		Injector holds the Providers and is responsible for resolving the dependencies and injecting the instance of the Dependency to the Consumer

	Registering the Dependency with the Injector
	--------------------------------------------

	Angular Provides an instance of Injector & Provider to every component & directive in the application ( Consumers). It also creates an Injector instance at the module level and also at the root of the application. Basically, it creates a Tree of Injectors with parent-child relationship 

		The dependencies are registered with the Provider. This is done in the Providers metadata of the Injector.


					@Component({
					  selector: 'app-root',
					  templateUrl: './app.component.html',
					  providers: [ProductService]
					})
					export class AppComponent
					{



		We can also add the Services to Providers array of the @NgModule. Then they will be available for use in all the components & Services of the application.

					@NgModule({
					  declarations: [...],
					  imports: [...],
					  providers: [ProductService],
					  bootstrap: []
					})

	//------------------------------------------------------------------------------------------------

Angular Dependency Injection Example

		- First, we need to register the dependencies with the provider. This is done in the providers metadata array of @Component decorator.
 
			providers: [ProductService]

		- Next, we need to tell angular that our component needs dependency injection. This is done by using the @Injectable() decorator.

		@Injectable() decorator is not needed if the class already has other Angular decorators like @Component, @pipe or @directive etc. Because all these are a subtype of Injectible.

		Since our AppComponent is already decorated with @Component, we do not need to decorate with the @Injectable

		- Next, our AppComponent needs to ask for the dependencies. We do that in the constructor of the Component.

			constructor(private productService:ProductService) { 
			}

	That’s it.
		When AppComponent is instantiated it gets its own Injector instance. The Injector knows that AppComponent requires ProductService by looking at its constructor. It then looks at the Providers for a match and Provides an instance of ProductService to the AppComponent

The Complete AppComponent is as follows. 

		import { Component } from '@angular/core';
		 
		import { ProductService } from './product.service';
		import { Product } from './product';
		 
		@Component({
		  selector: 'app-root',
		  templateUrl: './app.component.html',
		  providers: [ProductService]
		})
		export class AppComponent
		{
		 
		   products:Product[];
		   
		   constructor(private productService:ProductService){
		   }
		   
		   getProducts() {
		     this.products=this.productService.getProducts();
		   }
		  
		}


		-  Now let us inject service into another service.

			Create the logger.service.ts

				import { Injectable } from '@angular/core';
				 
				@Injectable()
				export class LoggerService {
				  log(message:any) {
				    console.log(message);
				  }
				}

		- Now we want to inject this into our ProductService class. The ProductService needs loggerService to be injected. Hence the class requires @Injectible Metadata

		@Injectable()
		export class ProductService{}


		- Next, In the constructor of the ProductService ask for the loggerService.
 
		constructor(private loggerService: LoggerService) {
		    this.loggerService.log("Product Service Constructed");
		}


	- Now update the getProducts method to use the Logger Service.

	 	public  getProducts() {
	 
	        this.loggerService.log("getProducts called");
	        let products:Product[];
	 
	        products=[
	            new Product(1,'Memory Card',500),
	            new Product(1,'Pen Drive',750),
	            new Product(1,'Power Bank',100)
	        ]
	 
	        this.loggerService.log(products);
	        return products;               
	    }	


	- Finally, we need to register LoggerService with the Providers metadata.

			providers: [ProductService,LoggerService]



	-  we registered the dependencies in the Providers array of the component class. The dependencies are only available to the component where we register them and to its child components.

	To Make the dependencies available to the entire application, we need to register it in the root module.


	Remove the providers: [ProductService,LoggerService], from the AppComponent and move it to the  AppModule as shown below

	import { BrowserModule } from '@angular/platform-browser';
		import { NgModule } from '@angular/core';
		import { HttpModule } from '@angular/http';
		import { FormsModule } from '@angular/forms';
		 
		import { AppComponent } from './app.component';
		 
		import { ProductService } from './product.service';
		import { LoggerService } from './logger.service';
		 
		@NgModule({
		  declarations: [
		    AppComponent
		  ],
		  imports: [
		    BrowserModule,
		    HttpModule,
		    FormsModule
		  ],
		  providers: [ProductService,LoggerService],
		  bootstrap: [AppComponent]
		})
		export class AppModule { }

		(Providing the service in the root module will create a single, shared instance of service and injects into any class that asks for it.)



	- Instead of adding ProductService to providers of the AppModule, you can also add it in the providedIn metadata with the value root.

	In fact, using the ProvidedIn is the preferred way to provide a service in a module

			 
			@Injectable({
			  providedIn:'root'
			})
			export class ProductService {
			 
			@Injectable({
			  providedIn:'root'
			})
			export class LoggerService {
	
	- The services that we provide at the root module are app-scoped, which means that we can access them from every component/service within the app.

	- Just execute the command  ng g s test (creates the service), read the decorators carefully.


//----------------------------------------------------------------------------------------------------

	// Routing: 

	What is Routing
		
		Routing allows you to move from one part of the application to another part or one View to another View.

		Angular Router is a powerful JavaScript router built and maintained by the Angular core team that can be installed from the @angular/router package. It provides a complete routing library with the possibility to have multiple router outlets, different path matching strategies, easy access to route parameters and route guards to protect components from unauthorized access.

		The Angular router is a core part of the Angular platform. It enables developers to build Single Page Applications with multiple views and allow navigation between these views.


		Using Angular Router you can

		- Navigate to a specific view by typing a URL in the address bar
		- Pass optional parameters to the View
		- Bind the clickable elements to the View and load the view when the user performs application tasks
		- Handles back and forward buttons of the browser
		- Allows you to dynamically load the view
		- Protect the routes from unauthorized users using Guards


		Let’s now see the essential Router concepts in more details.


		Router

		The Angular Router is an object that enables navigation from one component to the next component as users perform application tasks like clicking on menus links, buttons or clicking on back/forward button on the browser. We can access the router object and use its methods like navigate() or navigateByUrl(), to navigate to a route

		Route

		Route tells the Angular Router which view to display when a user clicks a link or pastes a URL into the browser address bar. Every Route consists of a path and a component it is mapped to. The Router object parses and builds the final URL using the Route


	RouterLink

		The RouterLink is a directive that binds the HTML element to a Route. Clicking on the HTML element, which is bound to a RouterLink, will result in navigation to the Route. The RouterLink may contain parameters to be passed to the route’s component.


	THE ROUTER-OUTLET 

		The Router-Outlet is a directive that’s available from the router library where the Router inserts the component that gets matched based on the current browser’s URL. You can add multiple outlets in your Angular application which enables you to implement advanced routing scenarios.

		<router-outlet></router-outlet>

		Any component that gets matched by the Router will render it as a sibling of the Router outlet.

	ROUTES AND PATHS 

		Routes are definitions (objects) comprised from at least a path and a component (or a redirectTo path) attributes. The path refers to the part of the URL that determines a unique view that should be displayed, and component refers to the Angular component that needs to be associated with a path. Based on a route definition that we provide (via a static RouterModule.forRoot(routes) method), the Router is able to navigate the user to a specific view.

		e.g.

			 { path:  'contacts', component:  ContactListComponent}


	ROUTE MATCHING STRATEGIES 

		The Angular Router provides different route matching strategies. The default strategy is simply checking if the current browser’s URL is prefixed with the path.

		For example our previous route:

		{ path:  'contacts', component:  ContactListComponent}



	ROUTE PARAMS 

		Creating routes with parameters is a common feature in web apps. Angular Router allows you to access parameters in different ways:

		Using the ActivatedRoute service,
		Using the ParamMap observable available starting with v4.
		You can create a route parameter using the colon syntax. 

		This is an example route with an id parameter:

		{ path:  'contacts/:id', component:  ContactDetailComponent}


		ROUTE GUARDS 

		A route guard is a feature of the Angular Router that allows developers to run some logic when a route is requested, and based on that logic, it allows or denies the user access to the route. It’s commonly used to check if a user is logged in and has the authorization before he can access a page.

		You can add a route guard by implementing the CanActivate interface available from the @angular/router package and extends the canActivate() method which holds the logic to allow or deny access to the route. For example, the following guard will always allow access to a route:

		class MyGuard implements CanActivate {
		  canActivate() {
		    return true;
		  }
		}


	NAVIGATION DIRECTIVE 

		The Angular Router provides the routerLink directive to create navigation links. This directive takes the path associated with the component to navigate to. For example:

			<a [routerLink]="'/contacts'">Contacts</a>


	MULTIPLE OUTLETS AND AUXILIARY ROUTES 

		Angular Router supports multiple outlets in the same application.

		A component has one associated primary route and can have auxiliary routes. Auxiliary routes enable developers to navigate multiple routes at the same time.

		To create an auxiliary route, you’ll need a named router outlet where the component associated with the auxiliary route will be displayed.

		<router-outlet></router-outlet>  
		<router-outlet  name="outlet1"></router-outlet> 
	
		- The outlet with no name is the primary outlet.
		- All outlets should have a name except for the primary outlet.

		You can then specify the outlet where you want to render your component using the outlet attribute:

		{ path: "contacts", component: ContactListComponent, outlet: "outlet1" }



//--------------------------------------------------------------------------------------------------

	Asynchronous Operations:

	Asynchronous programming is an important technique to create web applications. It allows units of work to run separately from the primary application thread and makes main application responsive.

	An async function can contain an await expression that pauses the execution of the async function and waits for the passed Promise's resolution, and then resumes the async function's execution and evaluates as the resolved value.

	Remember, the await keyword is only valid inside async functions. If you use it outside of an async function's body, you will get a SyntaxError.


	•	Promises

			Promises were added to JavaScript in ES6, also known as ECMAScript 2015. The reason for it was to simplify handling of asynchronous requests. Promise is a proxy for a value which is not yet known at the time of promise creation. 

			A promise can be in three different states:

			- Pending
			- Fulfilled
			- Rejected



			Let’s see how promises can be used:

			function get(url) {
			 // Return a new promise object
			  return new Promise((resolve, reject) => {
			   // Initialise an api call
			    $.ajax(url, {
			      method: "GET",
			      success: function(data, textStatus, jqXHR) {
			        // API call was successful, so we resolve the promise
			        // it will change state to ‘fulfilled’
			        resolve(data);
			      },
			      error: function(jqXHR, textStatus, errorThrown) {
			        // API call failed, so we reject the promise
			        // it will change state to ‘rejected’
			        reject(errorThrown);
			      }
			    });
			  });
			}

			get("https://swapi.co/api/people")
			  .then(response => {
			    console.log("response", response);
			  })
			  .catch(error => {
			    console.log("There was a problem while fetching data.");
			    console.error(error);
			  })
			  .finally(() => {
			    console.log('request completed')
			  })```



	•	Observables in Angular
			Angular makes use of observables as an interface to handle a variety of common asynchronous operations. 

			e.g.

				- The EventEmitter class extends Observable, specifically Subject
				- The HTTP module uses observables to handle AJAX requests and responses.
				- The Router and Forms modules use observables to listen for and respond to user-input events.


				Create an observable from a promise

				import { from, Observable } from 'rxjs';

				// Create an Observable out of a promise
				const data = from(fetch('/api/endpoint'));
				// Subscribe to begin listening for async result
				data.subscribe({
				  next(response) { console.log(response); },
				  error(err) { console.error('Error: ' + err); },
				  complete() { console.log('Completed'); }
				});

	•	Using HttpClient with Promises using toPromise

		RxJS provides the toPromise() operator which converts an Observable to a promise so you can work with the HttpClient methods using promises instead of Observables. We have previously seen that with an example:

				  private fetchData(){
				    const promise = this.httpClient.get(this.apiUrl).toPromise();
				    console.log(promise);  
				    promise.then((data)=>{
				      console.log("Promise resolved with: " + JSON.stringify(data));
				    }).catch((error)=>{
				      console.log("Promise rejected with " + JSON.stringify(error));
				    });
				    
				We call the get() method which returns an Observable but thanks to toPromise() we get a promise and we call the then() method to send the API request and provide a callback that displays date once it's fetched.









